"""
Программа предусматривает ввод с клавиатуры или из файла.

Алгоритм моего решения такой:
Бесконечная последовательность в начале программы - это пустая  строка.
Будем искать необходидый шаблон цифр последовательно увеличивая
нашу строковую "бесконечную" последовательность, до тех пор пока не найдём.

НО (!!!) как оказалось это не очень быстро и при тестировании программы на числе 1000000
мой компьютер на меня обиделся и сказал что не был к этому готов:( .
Поэтому алгоритм пришлось немного пересмотреть:

Суть такая:
будем искать нужный шаблон не во всей последовательности, а в срезе, постепенно сдвигая его в сторону увеличения.
Более подробно описал в комментарии в исполняемой части кода (строка 50)
"""

import sys				# для получения аргументов командной строки

what_find = list()		# список задаваемых последовательностей

if len(sys.argv) > 1:							# Проверяем наличие фала при запуске из командной строки
	f = open(sys.argv[1], encoding="utf8")
	for number in f:
		print(int(number))
		what_find.append(str(int(number)))		# Добавляем шаблон в список.
	f.close()
	print()
else:											# ...если файл при запуске не указан...
	while 1:
		number=input()							# ... то предлагаем пользователю ввести вручную
		if len(number) :						# если не пустая строка
			what_find.append(number)			# ... добавляем последовательность в список
		else:
			break


for num in what_find:
	kol = 0								# Это своеобразный флаг, который будет помогать нам получать срез
										# последовательности, чтобы при больших значениях не проходить всё заново.
	flag = 0							# Это счётчик на который мы будем увеличивать последовательность.
	where_find = ''						# Бесконечную цифровую последовательность будем формировать не сразу.
	we_find = -1						# Флаг для выхода из цикла while. Если != -1, значит мы нашли то искали.
	while we_find == -1:
		flag += 1						# увеличиваем последовательность...
		where_find += str(flag)
		while len(where_find) < len(str(num)):	# если длина последовательности меньше длины искомого шаблона...
			flag += 1							# ... по-быстрому увеличим до равной длины
			where_find += str(flag)

		"""flag со временем начинает увеличиваться не на одну цифру (как в начале), а сравнивать нужно
		с единичным сдвигом. Для этого делаем ещё один цикл, равный длине флага flag
		и в нём берём не всю последовательность, а только срез, на который приросла последовательность.
		Если не находим то что искали, смещаем срез на порядок вправо, а если находим, то
		у нас есть флаг kol, который как раз и покажет где было первое вхождение. """
		for fl_len in range(len(str(flag))):
			index_ = where_find[kol:kol+len(str(num))].find(str(num))
			if index_ != -1:
				we_find = kol+1
				print(kol+1)
				break
			kol +=1



# ЭТО ТОЖЕ ПОЛНОСТЬЮ РАБОЧИЙ ВАРИАНТ - МОЖЕТЕ ПРОВЕРИТЬ :) - (С НЕГО НАЧИНАЛ), НО ПРИ БОЛЬШИХ ШАБЛОНАХ ОЧЕНЬ ТОРМОЗИТ.

"""
for num in what_find:							# Проходим по введённым последовательностям
	while 1:
		flag += 1								# Увеличиваем флаг
		where_find += str(flag)					# Увеличиваем пока что не бесконечную числовую последовательность на значение флага
		index_ = where_find.find('1000000')			# Ищем в строке необходимую последовательность цифр
		if (index_ == -1):						# Если не нашли...
			continue							# ... то уходим на увеличение флага и новый поиск
		else:
			print(index_+1)						# Если нашли, то печатаем
			break								# ... и переходим к поиску следующей последовательности

"""


# Ну ОЧЕНЬ хочется к вам попасть! :))
